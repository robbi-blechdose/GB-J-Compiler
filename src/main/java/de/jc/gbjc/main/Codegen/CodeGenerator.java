/**
 * The GB-J Compiler
 * Copyright (C) 2019 - 2020 robbi-blechdose
 * Licensed under GNU AGPLv3
 * (See LICENSE.txt for full license)
 */
package de.jc.gbjc.main.Codegen;

import de.jc.gbjc.main.AssemblerRunner;
import de.jc.gbjc.main.Constants;
import de.jc.gbjc.main.Parsing.AbstractSyntaxTree;
import de.jc.gbjc.main.Util.Logger;
import de.jc.gbjc.main.Parsing.PreliminaryParser;
import de.jc.gbjc.main.VarHelper;
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author robbi-blechdose
 * 
 */
//TO-DO: Allow objects to contain objects? (when getting the pointer, check as usual: stack - WRAM - object memory)
public class CodeGenerator
{
    public static enum VariableType
    {
        FUNC_ARG, STACK_VAR, STATIC, OBJECT;
    }
    
    private int optimizerPasses;
    private int mbcVariant;
    
    private AbstractSyntaxTree syntaxTree;
    private List<String> staticMethods;
    private List<String> objectTypes;
    private List<Integer> objectSizes;
    private List<String> objectConstructors;
    private List<String> objectMethods;
    private List<String> objectVariablePositions;
    private List<String> objectInstances;
    
    private Writer writer;
    
    private List<String> varDeclarations;
    private List<String> methodVarDeclarations; //<method>|<var name>
    private List<String> objectVariableDeclarations;
    private List<String> generatedCode;
    private List<String> data; //Data is added at the end
    
    private AbstractSyntaxTree currentFunction;
    public int stackOffset;
    private int manualStackOffset; //Not the best name but me, whatever
    private int currentNumberOfArgs;
    private boolean popOnReturn;
//    
//    /**
//     * The code generator
//     * 
//     * @param ast The AST generated by the parser
//     * @param filename The name of the ASM file to output
//     * @param pp The preliminary parser instance for this file
//     * @param optimizerPasses The amount of optimizer passes to run
//     * @param mbcVariant The MBC variant this ROM should use
//     */
//    public CodeGenerator(AbstractSyntaxTree ast, String filename, PreliminaryParser pp, int optimizerPasses, int mbcVariant)
//    {
//        this.syntaxTree = ast;
//        this.staticMethods = pp.getStaticMethods();
//        this.objectTypes = pp.getObjectTypes();
//        this.objectSizes = pp.getObjectSizes();
//        this.objectConstructors = pp.getObjectConstructors();
//        this.objectMethods = pp.getObjectMethods();
//        this.objectVariablePositions = pp.getObjectVariablePositions();
//        this.objectInstances = pp.getObjectInstances();
//        
//        this.varDeclarations = new ArrayList<String>();
//        this.methodVarDeclarations = new ArrayList<String>();
//        this.objectVariableDeclarations = new ArrayList<String>();
//        this.generatedCode = new ArrayList<String>();
//        this.data = new ArrayList<String>();
//        
//        this.manualStackOffset = 0;
//        
//        try
//        {
//            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("build/" + filename + ".asm"), "utf-8"));
//        }
//        catch (Exception e)
//        {
//            Logger.getInstance().log(Logger.ERROR, "Failed to create file.");
//            Logger.getInstance().log(Logger.ERROR, e);
//            System.exit(-1);
//        }
//        
//        this.optimizerPasses = optimizerPasses;
//        this.mbcVariant = mbcVariant;
//    }
//    
//    /**
//     * Outputs a syntax error and terminates the program
//     * 
//     * @param line The line the error occured on
//     * @param message A description of the error
//     */
//    public void syntaxError(int line, String message)
//    {
//        Logger.getInstance().log(Logger.ERROR, "Syntax error on line " + line + ": " + message);
//        System.exit(0);
//    }
//    
//    /**
//     * 
//     * @param line The line the error occured on
//     */
//    public void incorrectAssignmentError(int line)
//    {
//        syntaxError(line, "Attempt to assign 16-bit value to 8-bit variable.");
//    }
//    
//    /**
//     * 
//     * @param line The line the error occured on
//     */
//    public void numberTooBigError(int line)
//    {
//        syntaxError(line, "Number is out of bounds.");
//    }
//    
//    /**
//     * 
//     * @param line The line the error occured on
//     * @param want The number of arguments that were expected
//     * @param got The number of supplied arguments
//     */
//    public void mismatchedArgumentNumberError(int line, int want, int got)
//    {
//        syntaxError(line, "Argument number mismatched: " + want + " Arguments expected but got " + got + ".");
//    }
//    
//    /**
//     * Retrieves the "bitNum" for a static (declared inside a section) variable<br>
//     * Can be 8 (char), 16 (int or pointer) or 0 (not found)
//     * 
//     * @param var The AST of the variable
//     * @return 
//     */
//    private int getBitNumForStaticVariable(AbstractSyntaxTree var)
//    {
//        for(String s : varDeclarations)
//        {
//            String[] parts = s.split("\\|");
//            if(parts[1].equals(var.getContent()))
//            {
//                if(parts[0].equals("char"))
//                {
//                    return Constants.CHAR_SIZE;
//                }
//                else if(parts[0].equals("int"))
//                {
//                    return Constants.INT_SIZE;
//                }
//                else if(objectTypes.contains(parts[0]))
//                {
//                    return Constants.REF_SIZE;
//                }
//                else if(parts[0].equals("array"))
//                {
//                    if(parts[2].equals("char"))
//                    {
//                        return Constants.CHAR_SIZE;
//                    }
//                    else
//                    {
//                        return Constants.INT_SIZE;
//                    }
//                }
//                else
//                {
//                    syntaxError(var.getLine(), "Type \"" + parts[0] + "\" does not exist.");
//                }
//            }
//        }
//        
//        syntaxError(var.getLine(), "Variable \"" + var.getContent() + "\" not defined.");
//        
//        return 0;
//    }
//    
//    /**
//     * Retrieves the "bitNum" for a variable declared inside the current method<br>
//     * Can be 8 (char), 16 (int or pointer) or 0 (not found)
//     * 
//     * @param var The AST of the variable
//     * @return 
//     */
//    private int getBitNumForMethodVariable(AbstractSyntaxTree var)
//    {
//        int varAmount = this.getNumberOfVarsForCurrentMethod();
//        
//        int index = 0;
//        for(String s : methodVarDeclarations)
//        {
//            String[] parts = s.split("\\|");
//            if(parts[0].equals(currentFunction.getContent()))
//            {
//                if(parts[2].equals(var.getContent()))
//                {
//                    if(parts[1].equals("char"))
//                    {
//                        this.stackOffset = (varAmount * 2) - (index * 2) - 2 + manualStackOffset;
//                        return Constants.CHAR_SIZE;
//                    }
//                    else if(parts[1].equals("int"))
//                    {
//                        this.stackOffset = (varAmount * 2) - (index * 2) - 2 + manualStackOffset;
//                        return Constants.INT_SIZE;
//                    }
//                    else if(objectTypes.contains(parts[1]))
//                    {
//                        this.stackOffset = (varAmount * 2) - (index * 2) - 2 + manualStackOffset;
//                        return Constants.REF_SIZE;
//                    }
//                    else
//                    {
//                        syntaxError(var.getLine(), "Type \"" + parts[0] + "\" does not exist.");
//                    }
//                }
//                index++;
//            }
//        }
//        
//        return 0;
//    }
//    
//    /**
//     * Retrieves the "bitNum" for a function argument of the current method<br>
//     * Can be 8 (char), 16 (int or pointer) or 0 (not found)
//     * 
//     * @param tree The AST we're generating the code from
//     * @return 
//     */
//    private int getBitNumForFunctionArg(AbstractSyntaxTree tree)
//    {
//        int numArgs = 0;
//        for(AbstractSyntaxTree ast : currentFunction.getChildren())
//        {
//            if(ast.getType() == TreeNodeType.FUNC_ARG)
//            {
//                numArgs++;
//            }
//        }
//        
//        currentNumberOfArgs = numArgs;
//        
//        for(AbstractSyntaxTree ast : currentFunction.getChildren())
//        {
//            if(ast.getType() == TreeNodeType.FUNC_ARG)
//            {
//                String[] parts = ast.getContent().split("\\|");
//                if(parts[1].equals(tree.getContent()))
//                {
//                    stackOffset = (numArgs - currentFunction.getChildren().indexOf(ast)) * 2;
//                    
//                    if(parts[0].equals("char"))
//                    {
//                        return Constants.CHAR_SIZE;
//                    }
//                    else if(parts[0].equals("int"))
//                    {
//                        return Constants.INT_SIZE;
//                    }
//                    else if(objectTypes.contains(parts[0]))
//                    {
//                        return Constants.REF_SIZE;
//                    }
//                    else
//                    {
//                        syntaxError(ast.getLine(), "Type \"" + parts[0] + "\" does not exist.");
//                    }
//                }
//            }
//        }
//        
//        return 0;
//    }
//    
//    /**
//     * Retrieves the "bitNum" for a variable declared inside an object<br>
//     * Can be 8 (char), 16 (int or pointer) or 0 (not found)
//     * 
//     * @param ast The AST of the variable
//     * @return 
//     */
//    private int getBitNumForObjectVariable(AbstractSyntaxTree ast)
//    {
//        for(String s : objectVariableDeclarations)
//        {
//            String[] parts = s.split("\\|");
//            if(parts[2].equals(ast.getContent()))
//            {
//                if(parts[1].equals("char"))
//                {
//                    return Constants.CHAR_SIZE;
//                }
//                else if(parts[1].equals("int"))
//                {
//                    return Constants.INT_SIZE;
//                }
//                else if(objectTypes.contains(parts[1]))
//                {
//                    return Constants.REF_SIZE;
//                }
//                else
//                {
//                    syntaxError(ast.getLine(), "Type \"" + parts[0] + "\" does not exist.");
//                }
//            }
//        }
//        
//        return 0;
//    }
//    
//    /**
//     * Loads the address of the desired object variable into hl
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param varName The name of the object variable
//     * @param stackOffset The stack offset to take into account
//     */
//    public void generateAddressForObjectVariable(List<String> code, String varName, int stackOffset)
//    {
//        //The address is located on the stack (since we're inside a method for an object taking the actual object memory as first argument)
//        code.add("ld hl, sp + " + ((currentNumberOfArgs * 2) + 2 + stackOffset) + "\n");
//        code.add("ld a, [hl+]\n");
//        code.add("ld h, [hl]\n");
//        code.add("ld l, a\n");
//
//        String offset = "";
//        for(String s : objectVariablePositions)
//        {
//            String[] parts = s.split("\\|");
//
//            if(parts[1].equals(varName))
//            {
//                offset = parts[2];
//            }
//        }
//
//        code.add("ld de, " + offset + "\n");
//        code.add("add hl, de\n");
//    }
//    
//    /**
//     * @return The number of variables declared in the current method
//     */
//    private int getNumberOfVarsForCurrentMethod()
//    {
//        int num = 0;
//        
//        for(String s : methodVarDeclarations)
//        {
//            String[] parts = s.split("\\|");
//            if(parts[0].equals(currentFunction.getContent()))
//            {
//                num++;
//            }
//        }
//        
//        return num;
//    }
//    
//    /**
//     * Locates a variable and determines bitNum and type
//     * 
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     * @return A VarHelper containing the bitNum and type of the variable
//     */
//    public VarHelper doVariableAccess(AbstractSyntaxTree tree, boolean isStatic)
//    {
//        int bitNum = getBitNumForFunctionArg(tree);
//        VariableType varType = VariableType.FUNC_ARG;
//        
//        //Calculate stack offset
//        stackOffset = manualStackOffset;
//        for(AbstractSyntaxTree ast : currentFunction.getChildren())
//        {
//            if(ast.getType() == TreeNodeType.FUNC_ARG)
//            {
//                stackOffset += 2;
//            }
//        }
//        stackOffset += (getNumberOfVarsForCurrentMethod() * 2);
//        
//        if(bitNum == 0)
//        {
//            if(isStatic)
//            {
//                int stackOffsetOld = stackOffset;
//                //This overwrites the stack offset, so save it in case we need it again
//                bitNum = getBitNumForMethodVariable(tree);
//                varType = VariableType.STACK_VAR;
//        
//                if(bitNum == 0)
//                {
//                    //Yup, we need it again
//                    stackOffset = stackOffsetOld;
//                    
//                    bitNum = getBitNumForStaticVariable(tree);
//                    varType = VariableType.STATIC;
//                }
//            }
//            else
//            {
//                bitNum = getBitNumForObjectVariable(tree);
//                varType = VariableType.OBJECT;
//            }
//        }
//        
//        return new VarHelper(bitNum, varType);
//    }
//    
//    /**
//     * Generates an array access<br>
//     * For writing: number to be written is in (b)c<br>
//     * For reading: number to be read will be in (b)c<br>
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The array access subtree
//     * @param bitNum The previously determined bitNum of the array
//     * @param isStatic Determines if this is a section (static) or an object class
//     * @param write Determines whether a write or a read is generated
//     */
//    public void generateArrayAccess(List<String> code, AbstractSyntaxTree tree, int bitNum, boolean isStatic, boolean write)
//    {
//        if(tree.getChildren().get(0).getType() == TreeNodeType.CONSTANT)
//        {
//            int arrayPos = Integer.parseInt(tree.getChildren().get(0).getContent());
//
//            if(write)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, c\n");
//                    code.add("ld [w" + tree.getContent() + " + " + arrayPos + "], a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld a, c\n");
//                    code.add("ld [w" + tree.getContent() + " + " + (arrayPos * 2) + "], a\n");
//                    code.add("ld a, b\n");
//                    code.add("ld [w" + tree.getContent() + " + " + (arrayPos * 2 + 1) + "], a\n");
//                }
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getContent() + " + " + arrayPos + "]\n");
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getContent() + " + " + (arrayPos * 2) + "]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld a, [w" + tree.getContent() + " + " + (arrayPos * 2 + 1) + "]\n");
//                    code.add("ld b, a\n");
//                }
//            }
//        }
//        else if(tree.getChildren().get(0).getType() == TreeNodeType.VARIABLE)
//        {
//            VarHelper vh2 = doVariableAccess(tree.getChildren().get(0), isStatic);
//            VariableType varType2 = vh2.getVarType();
//            int bitNum2 = vh2.getBitNum();
//
//            if(varType2 == VariableType.FUNC_ARG || varType2 == VariableType.STACK_VAR)
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld e, [hl]\n");
//                    code.add("ld d, 0\n");
//                }
//                else if(bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld d, [hl]\n");
//                    code.add("ld e, a\n");
//                }
//            }
//            else if(varType2 == VariableType.STATIC)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld e, a\n");
//                    code.add("ld d, 0\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld e, a\n");
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + " + 1]\n");
//                    code.add("ld d, a\n");
//                }
//            }
//            //Untested, but also unneeded
////            else if(varType2 == VariableType.OBJECT)
////            {
////                generateAddressForObjectVariable(tree.getChildren().get(0).getContent(), 0);
////
////                if(bitNum == 8)
////                {
////                    code.add("ld e, [hl]\n");
////                    code.add("ld d, 0\n");
////                }
////                else if(bitNum == 16)
////                {
////                    code.add("ld a, [hl+]\n");
////                    code.add("ld d, [hl]\n");
////                    code.add("ld e, a\n");
////                }
////            }
//
//            code.add("ld hl, w" + tree.getContent() + "\n");
//            code.add("add hl, de\n");
//            //If it's 2 bytes per array entry, we need to mult the position by 2
//            if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("add hl, de\n");
//            }
//            
//            if(write)
//            {
//                code.add("ld [hl], c\n");
//            }
//            else
//            {
//                code.add("ld c, [hl]\n");
//            }
//            
//            if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("inc hl\n");
//                
//                if(write)
//                {
//                    code.add("ld [hl], b\n");
//                }
//                else
//                {
//                    code.add("ld b, [hl]\n");
//                }
//            }
//        }
//    }
//    
//    private void generateDeclaration(AbstractSyntaxTree tree)
//    {
//        varDeclarations.add(tree.getContent());
//    }
//    
//    /**
//     * Generates a mathematical operation (+, -, *, /, %)
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateOperation(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        VarHelper vh = this.doVariableAccess(tree.getChildren().get(0), isStatic);
//        int bitNum = vh.getBitNum();
//        VariableType varType = vh.getVarType();
//        
//        AbstractSyntaxTree op = tree.getChildren().get(1);
//        
//        int bitNum2 = 0;
//        VariableType varType2;
//        int bitNum3 = 0;
//        VariableType varType3;
//        
//        if(op.getChildren().get(0).getType() == TreeNodeType.VARIABLE)
//        {
//            VarHelper vh2 = this.doVariableAccess(op.getChildren().get(0), isStatic);
//            bitNum2 = vh2.getBitNum();
//            varType2 = vh2.getVarType();
//            
//            if(varType2 == VariableType.FUNC_ARG || varType2 == VariableType.STACK_VAR)
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld c, [hl]\n");
//                }
//                else if(bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld a, [hl]\n");
//                    code.add("ld b, a\n");
//                }
//            }
//            else if(varType2 == VariableType.STATIC)
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + op.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + op.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld a, [w" + op.getChildren().get(0).getContent() + " + 1]\n");
//                    code.add("ld b, a\n");
//                }
//            }
//            else if(varType2 == VariableType.OBJECT)
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    generateAddressForObjectVariable(code, op.getChildren().get(0).getContent(), 0);
//                    code.add("ld c, [hl]\n");
//                }
//                else
//                {
//                    generateAddressForObjectVariable(code, op.getChildren().get(0).getContent(), 0);
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld b, [hl]\n");
//                    code.add("ld c, a\n");
//                }
//            }
//        }
//        else if(op.getChildren().get(0).getType() == TreeNodeType.CONSTANT)
//        {
//            int value = Integer.parseInt(op.getChildren().get(0).getContent());
//            if(value >= -128 && value <= 255)
//            {
//                bitNum2 = Constants.CHAR_SIZE;
//                code.add("ld c, " + value + "\n");
//            }
//            else if(value >= -32768 && value <= 65535)
//            {
//                bitNum2 = Constants.INT_SIZE;
//                code.add("ld bc, " + value + "\n");
//            }
//            else
//            {
//                numberTooBigError(op.getChildren().get(0).getLine());
//            }
//        }
//        else if(op.getChildren().get(0).getType() == TreeNodeType.ARRAY_ACCESS)
//        {
//            VarHelper vh2 = this.doVariableAccess(op.getChildren().get(0), isStatic);
//            bitNum2 = vh2.getBitNum();
//            varType2 = vh2.getVarType();
//            
//            generateArrayAccess(code, op.getChildren().get(0), bitNum2, isStatic, false);
//        }
//        
//        if(op.getChildren().get(1).getType() == TreeNodeType.VARIABLE)
//        {
//            VarHelper vh3 = this.doVariableAccess(op.getChildren().get(1), isStatic);
//            bitNum3 = vh3.getBitNum();
//            varType3 = vh3.getVarType();
//            
//            if(varType3 == VariableType.FUNC_ARG || varType3 == VariableType.STACK_VAR)
//            {
//                if(bitNum3 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld e, [hl]\n");
//                }
//                else if(bitNum3 == Constants.INT_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld e, a\n");
//                    code.add("ld a, [hl]\n");
//                    code.add("ld d, a\n");
//                }
//            }
//            else if(varType3 == VariableType.STATIC)
//            {
//                if(bitNum3 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + op.getChildren().get(1).getContent() + "]\n");
//                    code.add("ld e, a\n");
//                }
//                else if(bitNum3 == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + op.getChildren().get(1).getContent() + "]\n");
//                    code.add("ld e, a\n");
//                    code.add("ld a, [w" + op.getChildren().get(1).getContent() + " + 1]\n");
//                    code.add("ld d, a\n");
//                }
//            }
//            else if(varType3 == VariableType.OBJECT)
//            {
//                if(bitNum3 == Constants.CHAR_SIZE)
//                {
//                    generateAddressForObjectVariable(code, op.getChildren().get(1).getContent(), 0);
//                    code.add("ld e, [hl]\n");
//                }
//                else if(bitNum3 == Constants.REF_SIZE)
//                {
//                    generateAddressForObjectVariable(code, op.getChildren().get(1).getContent(), 0);
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld d, [hl]\n");
//                    code.add("ld e, a\n");
//                }
//            }
//        }
//        else if(op.getChildren().get(1).getType() == TreeNodeType.CONSTANT)
//        {
//            int value = Integer.parseInt(op.getChildren().get(1).getContent());
//            if(value >= -128 && value <= 255)
//            {
//                bitNum3 = Constants.CHAR_SIZE;
//                code.add("ld e, " + value + "\n");
//            }
//            else if(value >= -32768 && value <= 65535)
//            {
//                bitNum3 = Constants.INT_SIZE;
//                code.add("ld de, " + value + "\n");
//            }
//            else
//            {
//                numberTooBigError(op.getChildren().get(1).getLine());
//            }
//        }
//        else if(op.getChildren().get(1).getType() == TreeNodeType.ARRAY_ACCESS)
//        {
//            VarHelper vh3 = this.doVariableAccess(op.getChildren().get(1), isStatic);
//            bitNum3 = vh3.getBitNum();
//            varType3 = vh3.getVarType();
//            
//            code.add("push bc\n");
//            manualStackOffset = 2;
//            generateArrayAccess(code, op.getChildren().get(1), bitNum3, isStatic, false);
//            manualStackOffset = 0;
//            code.add("ld d, b\n");
//            code.add("ld e, c\n");
//            code.add("pop bc\n");
//        }
//        
//        //Check for incorrect assignments (assign 16-bit value to 8-bit var)
//        if(bitNum == Constants.CHAR_SIZE && (bitNum2 == Constants.INT_SIZE || bitNum3 == Constants.INT_SIZE))
//        {
//            incorrectAssignmentError(op.getChildren().get(0).getLine());
//        }
//        
//        if(op.getContent().equals("+"))
//        {
//            if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("add e\n");
//                
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                    code.add("ld c, a\n");
//                }
//            }
//            else
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum3 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                //Number 1 is in bc
//                //Number 2 is in de
//                //We want the result in bc
//                code.add("ld a, c\n");
//                code.add("add e\n"); //If the add "overflows", the extra bit is put into carry
//                code.add("ld c, a\n");
//                code.add("ld a, b\n");
//                code.add("adc d\n"); //Add with carry - we put the additional bit into the upper byte of the number
//                code.add("ld b, a\n");
//            }
//        }
//        else if(op.getContent().equals("-"))
//        {
//            if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("sub e\n");
//                
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                    code.add("ld c, a\n");
//                }
//            }
//            else
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum3 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                //Number 1 is in bc
//                //Number 2 is in de
//                //We want the result in bc
//                code.add("ld a, c\n");
//                code.add("sub e\n"); //If the add "overflows", the extra bit is put into carry
//                code.add("ld c, a\n");
//                code.add("ld a, b\n");
//                code.add("sbc d\n"); //Subtract with carry - we put the additional bit into the upper byte of the number
//                code.add("ld b, a\n");
//            }
//        }
//        else if(op.getContent().equals("*"))
//        {
//            if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld h, c\n");
//                code.add("call _mul8_8\n");
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld c, l\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld b, h\n");
//                    code.add("ld c, l\n");
//                }
//            }
//            else if(bitNum2 == Constants.INT_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, e\n");
//                code.add("ld d, b\n");
//                code.add("ld e, c\n");
//                code.add("call _mul16_8\n");
//                code.add("ld b, h\n");
//                code.add("ld c, l\n");
//            }
//            else if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.INT_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("call _mul16_8\n");
//                code.add("ld b, h\n");
//                code.add("ld c, l\n");
//            }
//            else
//            {
//                code.add("call _mul16_16\n");
//                code.add("ld b, h\n");
//                code.add("ld c, l\n");
//            }
//        }
//        else if(op.getContent().equals("/"))
//        {
//            if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld d, c\n");
//                code.add("call _div8_8\n");
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld c, d\n");
//                }
//                if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                    code.add("ld c, d\n");
//                }
//            }
//            else if(bitNum2 == Constants.INT_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld h, b\n");
//                code.add("ld l, c\n");
//                code.add("ld c, e\n");
//                code.add("call _div16_8\n");
//                code.add("ld b, h\n");
//                code.add("ld c, l\n");
//            }
//            else if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.INT_SIZE)
//            {
//                code.add("ld h, d\n");
//                code.add("ld l, e\n");
//                code.add("call _div16_8\n");
//                code.add("ld b, h\n");
//                code.add("ld c, l\n");
//            }
//            else
//            {
//                code.add("call _div16_16\n");
//            }
//        }
//        else if(op.getContent().equals("%"))
//        {
//            if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld d, c\n");
//                code.add("call _div8_8\n");
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                    code.add("ld c, a\n");
//                }
//            }
//            else if(bitNum2 == Constants.INT_SIZE && bitNum3 == Constants.CHAR_SIZE)
//            {
//                code.add("ld h, b\n");
//                code.add("ld l, c\n");
//                code.add("ld c, e\n");
//                code.add("call _div16_8\n");
//                code.add("ld b, 0\n");
//                code.add("ld c, a\n");
//            }
//            else if(bitNum2 == Constants.CHAR_SIZE && bitNum3 == Constants.INT_SIZE)
//            {
//                code.add("ld h, d\n");
//                code.add("ld l, e\n");
//                code.add("call _div16_8\n");
//                code.add("ld b, 0\n");
//                code.add("ld c, a\n");
//            }
//            else
//            {
//                code.add("call _div16_16\n");
//                code.add("ld b, d\n");
//                code.add("ld c, e\n");
//            }
//        }
//    }
//    
//    /**
//     * Instantiates an object:<br>
//     * - Calls malloc<br>
//     * - Calls the constructor of the object<br>
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     */
//    private void generateInstantiation(List<String> code, AbstractSyntaxTree tree)
//    {
//        int size = objectSizes.get(objectTypes.indexOf(tree.getContent()));
//        
//        code.add("ld bc, " + size + "\n");
//        code.add("call malloc\n");
//        code.add("ld bc, 6\n"); //Skip the 6 bytes header
//        code.add("add hl, bc\n");
//        code.add("push hl\n");
//        generateMethodCallArguments(code, tree.getChildren().get(0), tree);
//        code.add("call _" + tree.getContent() + "Constructor\n");
//        code.add("add sp, " + (tree.getChildren().get(0).getChildren().size() * 2) + "\n");
//        code.add("pop bc\n");
//    }
//    
//    /**
//     * Generates an assignment
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateAssignment(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        VarHelper vh = doVariableAccess(tree.getChildren().get(0), isStatic);
//        int bitNum = vh.getBitNum();
//        VariableType varType = vh.getVarType();
//        
//        int stackOffset = this.stackOffset;
//        
//        //Value to be assigned
//        if(tree.getChildren().get(1).getType() == TreeNodeType.CONSTANT)
//        {
//            int constant = Integer.parseInt(tree.getChildren().get(1).getContent());
//            
//            //Check for out of bounds
//            if((bitNum == Constants.CHAR_SIZE && (constant > 255 || constant < -128))
//                    || (bitNum == Constants.INT_SIZE && (constant > 65535 || constant < -32768)))
//            {
//                numberTooBigError(tree.getChildren().get(1).getLine());
//            }
//
//            if(bitNum == Constants.CHAR_SIZE)
//            {
//                code.add("ld c, " + constant + "\n");
//            }
//            else if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("ld bc, " + constant + "\n");
//            }
//        }
//        else if(tree.getChildren().get(1).getType() == TreeNodeType.VARIABLE)
//        {
//            VarHelper vh2 = doVariableAccess(tree.getChildren().get(1), isStatic);
//            int bitNum2 = vh2.getBitNum();
//            VariableType varType2 = vh2.getVarType();
//            
//            if(varType2 == VariableType.FUNC_ARG || varType2 == VariableType.STACK_VAR)
//            {
//                if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + this.stackOffset + "\n");
//                    code.add("ld c, [hl]\n");
//                }
//                else if(bitNum == Constants.INT_SIZE && bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld hl, sp + " + this.stackOffset + "\n");
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld b, [hl]\n");
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE && bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + this.stackOffset + "\n");
//                    code.add("ld c, [hl]\n");
//                    code.add("ld b, 0\n");
//                }
//                else
//                {
//                    incorrectAssignmentError(tree.getChildren().get(1).getLine());
//                }
//            }
//            else if(varType2 == VariableType.STATIC)
//            {
//                if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(1).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE && bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(1).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld a, [w" + tree.getChildren().get(1).getContent() + " + 1]\n");
//                    code.add("ld b, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE && bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(1).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld b, 0\n");
//                }
//                else
//                {
//                    incorrectAssignmentError(tree.getChildren().get(1).getLine());
//                }
//            }
//            else if(varType2 == VariableType.OBJECT)
//            {
//                generateAddressForObjectVariable(code, tree.getChildren().get(1).getContent(), 0);
//
//                if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld c, [hl]\n");
//                }
//                else if(bitNum == Constants.INT_SIZE && bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld b, [hl]\n");
//                }
//                else if(bitNum == Constants.INT_SIZE && bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld c, [hl]\n");
//                    code.add("ld b, 0\n");
//                }
//                else
//                {
//                    incorrectAssignmentError(tree.getChildren().get(1).getLine());
//                }
//            }
//        }
//        else if(tree.getChildren().get(1).getType() == TreeNodeType.OPERATION)
//        {
//            generateOperation(code, tree, isStatic);
//        }
//        else if(tree.getChildren().get(1).getType() == TreeNodeType.INSTANTIATION)
//        {
//            generateInstantiation(code, tree.getChildren().get(1));
//        }
//        else if(tree.getChildren().get(1).getType() == TreeNodeType.ARRAY_ACCESS)
//        {
//            VarHelper vh3 = doVariableAccess(tree.getChildren().get(1), isStatic);
//            generateArrayAccess(code, tree.getChildren().get(1), vh3.getBitNum(), isStatic, false);
//        }
//        
//        if(varType == VariableType.FUNC_ARG || varType == VariableType.STACK_VAR)
//        {
//            if(bitNum == Constants.CHAR_SIZE)
//            {
//                code.add("ld hl, sp + " + stackOffset + "\n");
//                code.add("ld [hl], c\n");
//            }
//            else if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("ld hl, sp + " + stackOffset + "\n");
//                code.add("ld a, c\n");
//                code.add("ld [hl+], a\n");
//                code.add("ld a, b\n");
//                code.add("ld [hl], a\n");
//            }
//        }
//        else if(varType == VariableType.STATIC)
//        {
//            if(tree.getChildren().get(0).getType() == TreeNodeType.ARRAY_ACCESS)
//            {
//                generateArrayAccess(code, tree.getChildren().get(0), bitNum, isStatic, true);
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, c\n");
//                    code.add("ld [w" + tree.getChildren().get(0).getContent() + "], a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld a, c\n");
//                    code.add("ld [w" + tree.getChildren().get(0).getContent() + "], a\n");
//                    code.add("ld a, b\n");
//                    code.add("ld [w" + tree.getChildren().get(0).getContent() + " + 1], a\n");
//                }
//            }
//        }
//        else if(varType == VariableType.OBJECT)
//        {
//            generateAddressForObjectVariable(code, tree.getChildren().get(0).getContent(), 0);
//
//            if(bitNum == Constants.CHAR_SIZE)
//            {
//                code.add("ld [hl], c\n");
//            }
//            else if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("ld [hl+], a\n");
//                code.add("ld [hl], b\n");
//            }
//        }
//    }
//    
//    /**
//     * Generates a condition:<br>
//     * Valid ones are {@literal <}, {@literal <=}, ==, !=, {@literal >=}, {@literal >}
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param trueLabel The label we jump to if the condition evaluates to true
//     * @param falseLabel The label we jump to if the condition evaluates to false
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateCondition(List<String> code, AbstractSyntaxTree tree, String trueLabel, String falseLabel, boolean isStatic)
//    {
//        int bitNum = 0;
//        VariableType varType;
//        int bitNum2 = 0;
//        VariableType varType2;
//        
//        //If we have two constants, optimize out the comparison
//        if(tree.getChildren().get(0).getType() == TreeNodeType.CONSTANT && tree.getChildren().get(1).getType() == TreeNodeType.CONSTANT)
//        {
//            Logger.getInstance().log(Logger.FINE, "Comparison between two constants on line " + tree.getChildren().get(0).getLine() +
//                    ". Replacing with unconditional jump.");
//            
//            int a = Integer.parseInt(tree.getChildren().get(0).getContent());
//            int b = Integer.parseInt(tree.getChildren().get(1).getContent());
//            
//            if(tree.getContent().equals("<") && a < b)
//            {
//                code.add("jp " + trueLabel + "\n");
//            }
//            else if(tree.getContent().equals("<=") && a <= b)
//            {
//                code.add("jp " + trueLabel + "\n");
//            }
//            else if(tree.getContent().equals("==") && a == b)
//            {
//                code.add("jp " + trueLabel + "\n");
//            }
//            else if(tree.getContent().equals("!=") && a != b)
//            {
//                code.add("jp " + trueLabel + "\n");
//            }
//            else if(tree.getContent().equals(">=") && a >= b)
//            {
//                code.add("jp " + trueLabel + "\n");
//            }
//            else if(tree.getContent().equals(">") && a > b)
//            {
//                code.add("jp " + trueLabel + "\n");
//            }
//            else
//            {
//                code.add("jp " + falseLabel + "\n");
//                Logger.getInstance().log(Logger.WARNING, "Having a constant comparison evaluate to false doesn't make much sense. Maybe change this?");
//            }
//            
//            return;
//        }
//        
//        //First operand goes in (b)c, second in (d)e
//        if(tree.getChildren().get(0).getType() == TreeNodeType.VARIABLE)
//        {
//            VarHelper vh = this.doVariableAccess(tree.getChildren().get(0), isStatic);
//            bitNum = vh.getBitNum();
//            varType = vh.getVarType();
//            
//            if(varType == VariableType.FUNC_ARG || varType == VariableType.STACK_VAR)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld c, [hl]\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld a, [hl]\n");
//                    code.add("ld b, a\n");
//                }
//            }
//            else if(varType == VariableType.STATIC)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + " + 1]\n");
//                    code.add("ld b, a\n");
//                }
//            }
//            else if(varType == VariableType.OBJECT)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    generateAddressForObjectVariable(code, tree.getChildren().get(0).getContent(), 0);
//                    code.add("ld c, [hl]\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    generateAddressForObjectVariable(code, tree.getChildren().get(0).getContent(), 0);
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld b, [hl]\n");
//                    code.add("ld c, a\n");
//                }
//            }
//        }
//        else if(tree.getChildren().get(0).getType() == TreeNodeType.CONSTANT)
//        {
//            int value = Integer.parseInt(tree.getChildren().get(0).getContent());
//            
//            if(value <= 255 || value >= -128)
//            {
//                bitNum = Constants.CHAR_SIZE;
//                code.add("ld c, " + value + "\n");
//            }
//            else if(value <= 65535 || value >= -32768)
//            {
//                bitNum = Constants.INT_SIZE;
//                code.add("ld bc, " + value + "\n");
//            }
//            else
//            {
//                numberTooBigError(tree.getChildren().get(0).getLine());
//            }
//        }
//        else if(tree.getChildren().get(0).getType() == TreeNodeType.CALL ||
//                tree.getChildren().get(0).getType() == TreeNodeType.OBJECT_CALL)
//        {
//            //Method returns in c or bc
//            bitNum = generateMethodCall(code, tree.getChildren().get(0), 0);
//        }
//        else if(tree.getChildren().get(0).getType() == TreeNodeType.ARRAY_ACCESS)
//        {
//            VarHelper vh = this.doVariableAccess(tree.getChildren().get(0), isStatic);
//            bitNum = vh.getBitNum();
//            varType = vh.getVarType();
//            
//            this.generateArrayAccess(code, tree.getChildren().get(0), bitNum, isStatic, false);
//        }
//            
//        if(tree.getChildren().get(1).getType() == TreeNodeType.VARIABLE)
//        {
//            VarHelper vh2 = this.doVariableAccess(tree.getChildren().get(1), isStatic);
//            bitNum2 = vh2.getBitNum();
//            varType2 = vh2.getVarType();
//            
//            if(varType2 == VariableType.FUNC_ARG || varType2 == VariableType.STACK_VAR)
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld e, [hl]\n");
//                }
//                else if(bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld e, a\n");
//                    code.add("ld a, [hl]\n");
//                    code.add("ld d, a\n");
//                }
//            }
//            else if(varType2 == VariableType.STATIC)
//            {
//                if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(1).getContent() + "]\n");
//                    code.add("ld e, a\n");
//                }
//                else if(bitNum2 == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(1).getContent() + "]\n");
//                    code.add("ld e, a\n");
//                    code.add("ld a, [w" + tree.getChildren().get(1).getContent() + " + 1]\n");
//                    code.add("ld d, a\n");
//                }
//            }
//            else if(varType2 == VariableType.OBJECT)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    generateAddressForObjectVariable(code, tree.getChildren().get(1).getContent(), 0);
//                    code.add("ld e, [hl]\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    generateAddressForObjectVariable(code, tree.getChildren().get(1).getContent(), 0);
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld d, [hl]\n");
//                    code.add("ld e, a\n");
//                }
//            }
//        }
//        else if(tree.getChildren().get(1).getType() == TreeNodeType.CONSTANT)
//        {
//            int value = Integer.parseInt(tree.getChildren().get(1).getContent());
//            
//            if(value <= 255 || value >= -128)
//            {
//                bitNum2 = Constants.CHAR_SIZE;
//                code.add("ld e, " + value + "\n");
//            }
//            else if(value <= 65535 || value >= -32768)
//            {
//                bitNum2 = Constants.INT_SIZE;
//                code.add("ld de, " + value + "\n");
//            }
//            else
//            {
//                numberTooBigError(tree.getChildren().get(1).getLine());
//            }
//        }
//        else if(tree.getChildren().get(1).getType() == TreeNodeType.CALL ||
//                tree.getChildren().get(1).getType() == TreeNodeType.OBJECT_CALL)
//        {
//            code.add("push bc\n");
//            manualStackOffset = 2;
//            //Method returns in c or bc
//            bitNum2 = generateMethodCall(code, tree.getChildren().get(1), 0);
//            code.add("ld d, b\n");
//            code.add("ld e, c\n");
//            manualStackOffset = 0;
//            code.add("pop bc\n");
//        }
//        else if(tree.getChildren().get(1).getType() == TreeNodeType.ARRAY_ACCESS)
//        {
//            VarHelper vh = doVariableAccess(tree.getChildren().get(1), isStatic);
//            bitNum = vh.getBitNum();
//            varType = vh.getVarType();
//            
//            code.add("push bc\n");
//            manualStackOffset = 2;
//            generateArrayAccess(code, tree.getChildren().get(1), bitNum, isStatic, false);
//            code.add("ld d, b\n");
//            code.add("ld e, c\n");
//            manualStackOffset = 0;
//            code.add("pop bc\n");
//        }
//        
//        if(tree.getContent().equals(">"))
//        {
//            if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, e\n");
//                code.add("cp c\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                code.add("ld a, d\n");
//                code.add("cp b\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("ld a, e\n");
//                code.add("cp c\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//        }
//        else if(tree.getContent().equals(">="))
//        {
//            
//            if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, e\n");
//                code.add("cp c\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp z, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                code.add("ld a, d\n");
//                code.add("cp b\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp nz, " + falseLabel + "\n");
//                code.add("ld a, e\n");
//                code.add("cp c\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp z, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//        }
//        else if(tree.getContent().equals("=="))
//        {
//            if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp z, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                code.add("ld a, b\n");
//                code.add("cp d\n");
//                code.add("jp nz, " + falseLabel + "\n");
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp z, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//        }
//        else if(tree.getContent().equals("!="))
//        {
//            if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp nz, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                code.add("ld a, b\n");
//                code.add("cp d\n");
//                code.add("jp z, " + falseLabel + "\n");
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp nz, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//        }
//        else if(tree.getContent().equals("<="))
//        {
//            if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp z, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                code.add("ld a, b\n");
//                code.add("cp d\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp nz, " + falseLabel + "\n");
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp z, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//        }
//        else if(tree.getContent().equals("<"))
//        {
//            if(bitNum == Constants.CHAR_SIZE && bitNum2 == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//            else
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum2 == Constants.CHAR_SIZE)
//                {
//                    code.add("ld d, 0\n");
//                }
//                
//                code.add("ld a, b\n");
//                code.add("cp d\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("ld a, c\n");
//                code.add("cp e\n");
//                code.add("jp c, " + trueLabel + "\n");
//                code.add("jp " + falseLabel + "\n");
//            }
//        }
//    }
//    
//    /**
//     * Generates an if block, possibly with else if's and an else
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateIfElseBlock(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        boolean hasElse = false;
//        
//        for(AbstractSyntaxTree ast : tree.getChildren())
//        {
//            //Found the condition
//            if(ast.getType() == TreeNodeType.CONDITION)
//            {
//                generateCondition(code, ast, "_" + Math.abs(tree.hashCode()) + "body", "_" + Math.abs(tree.hashCode()) + "false", isStatic);
//            }
//            else if(ast.getType() == TreeNodeType.IF)
//            {
//                hasElse = true;
//                code.add("_" + Math.abs(tree.hashCode()) + "false:\n");
//                generateIfElseBlock(code, ast, isStatic);
//            }
//            else if(ast.getType() == TreeNodeType.ELSE)
//            {
//                hasElse = true;
//                code.add("_" + Math.abs(tree.hashCode()) + "false:\n");
//                generateStatementSequence(code, ast, isStatic);
//                code.add("jp _" + Math.abs(tree.hashCode()) + "end\n");
//            }
//            //If statement body
//            else if(ast.getType() == TreeNodeType.BODY)
//            {
//                code.add("_" + Math.abs(tree.hashCode()) + "body:\n");
//                generateStatementSequence(code, ast, isStatic);
//                code.add("jp _" + Math.abs(tree.hashCode()) + "end\n");
//            }
//        }
//        
//        if(!hasElse)
//        {
//            code.add("_" + Math.abs(tree.hashCode()) + "false:\n");
//        }
//        
//        code.add("_" + Math.abs(tree.hashCode()) + "end:\n");
//    }
//    
//    /**
//     * Generates a while loop
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateWhileLoop(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        //Jump to the condition so that it's checked before we execute code (otherwise this would be a do-while loop)
//        code.add("jp _" + Math.abs(tree.hashCode()) + "check\n");
//        code.add("_" + Math.abs(tree.hashCode()) + "loop:\n");
//        
//        //A while loop tree should only contain a condition at index 0 and a body at index 1
//        if(tree.getChildren().get(1).getType() == TreeNodeType.BODY)
//        {
//            generateStatementSequence(code, tree.getChildren().get(1), isStatic);
//        }
//        
//        //The condition comes after the body in ASM loops, otherwise we have a do-while loop and noone likes those
//        if(tree.getChildren().get(0).getType() == TreeNodeType.CONDITION)
//        {
//            code.add("_" + Math.abs(tree.hashCode()) + "check:\n");
//            generateCondition(code, tree.getChildren().get(0), "_" + Math.abs(tree.hashCode()) + "loop", "_" + Math.abs(tree.hashCode()) + "end", isStatic);
//        }
//        
//        code.add("_" + Math.abs(tree.hashCode()) + "end:\n");
//    }
//    
//    /**
//     * Checks if a constant with the given name exists, and uses it as a method argument if it does
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param str The name of the constant
//     * @return If a constant of that name exists
//     */
//    private boolean checkGenerateConstant(List<String> code, String str)
//    {
//        if(Constants.getContants().containsKey(str))
//        {
//            code.add("ld h, 0\n");
//            code.add("ld l, " + Constants.getContants().get(str) + "\n");
//            code.add("push hl\n");
//            return true;
//        }
//        return false;
//    }
//    
//    /**
//     * Generates special cases where normal methods are not used
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @return If a method was found and a call generated
//     */
//    private boolean tryGenerateInlineMethodCall(List<String> code, AbstractSyntaxTree tree)
//    {
//        //"halt()" is directly translated to a "halt" instruction
//        if(tree.getContent().equals("halt"))
//        {
//            code.add("halt\n");
//            if(!tree.getChildren().get(0).getChildren().isEmpty())
//            {
//                mismatchedArgumentNumberError(tree.getLine(), 0, tree.getChildren().get(0).getChildren().size());
//            }
//            return true;
//        }
//        //"waitVBlank()" is directly translated to an "rst $00" instruction - the restart vector is a VBlank waitloop
//        else if(tree.getContent().equals("waitVBlank"))
//        {
//            code.add("rst $00\n");
//            if(!tree.getChildren().get(0).getChildren().isEmpty())
//            {
//                mismatchedArgumentNumberError(tree.getLine(), 0, tree.getChildren().get(0).getChildren().size());
//            }
//            return true;
//        }
//        //"enableInterrupts()" is directly translated to an "ei" instruction
//        else if(tree.getContent().equals("enableInterrupts"))
//        {
//            code.add("ei\n");
//            if(!tree.getChildren().get(0).getChildren().isEmpty())
//            {
//                mismatchedArgumentNumberError(tree.getLine(), 0, tree.getChildren().get(0).getChildren().size());
//            }
//            return true;
//        }
//        else if(tree.getContent().equals("disableInterrupts"))
//        {
//            code.add("di\n");
//            if(!tree.getChildren().get(0).getChildren().isEmpty())
//            {
//                mismatchedArgumentNumberError(tree.getLine(), 0, tree.getChildren().get(0).getChildren().size());
//            }
//            return true;
//        }
//        //"lcdOn()" is parsed here since the arguments are not translated into actual function arguments
//        else if(tree.getContent().equals("lcdOn"))
//        {
//            String s = "ld a, %";
//
//            AbstractSyntaxTree args = tree.getChildren().get(0);
//            
//            if(args.getChildren().size() != 8)
//            {
//                mismatchedArgumentNumberError(tree.getLine(), 8, args.getChildren().size());
//            }
//            
//            for(AbstractSyntaxTree bit : args.getChildren())
//            {
//                if(bit.getType() == TreeNodeType.VARIABLE && Constants.getContants().containsKey(bit.getContent()))
//                {
//                    s += Constants.getContants().get(bit.getContent());
//                }
//                else
//                {
//                    s += bit.getContent();
//                }
//            }
//
//            code.add(s + "\n");
//            code.add("ld [rLCDC], a\n");
//            return true;
//        }
//        //"softwareBreak()" is translated directly into a "ld b, b" which BGB can break on
//        else if(tree.getContent().equals("softwareBreak"))
//        {
//            code.add("ld b, b\n");
//            if(!tree.getChildren().get(0).getChildren().isEmpty())
//            {
//                mismatchedArgumentNumberError(tree.getLine(), 0, tree.getChildren().get(0).getChildren().size());
//            }
//            return true;
//        }
//        
//        return false;
//    }
//    
//    /**
//     * Generates all arguments for a function call and pushes them to the stack
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param args The AST containing the arguments to be generated
//     * @param funcTree The AST that is the function we're calling
//     */
//    private void generateMethodCallArguments(List<String> code, AbstractSyntaxTree args, AbstractSyntaxTree funcTree)
//    {
//        int stackOffset = 0;
//
//        for(AbstractSyntaxTree arg : args.getChildren())
//        {
//            switch(arg.getType())
//            {
//                case CONSTANT:
//                {
//                    code.add("ld hl, " + arg.getContent() + "\n");
//                    code.add("push hl" + "\n");
//                    break;
//                }
//                case VARIABLE:
//                {
//                    if(checkGenerateConstant(code, arg.getContent()))
//                    {
//                        break;
//                    }
//                    
//                    VarHelper vh = this.doVariableAccess(arg, false);
//                    if(vh.getBitNum() == 0)
//                    {
//                        vh = this.doVariableAccess(arg, true);
//                    }
//                    int bitNum = vh.getBitNum();
//                    VariableType type = vh.getVarType();
//                    
//                    if(type == VariableType.FUNC_ARG || type == VariableType.STACK_VAR)
//                    {
//                        //We add the stackOffset here to compensate for the already-pushed arguments
//                        if(bitNum == Constants.CHAR_SIZE)
//                        {
//                            code.add("ld hl, sp + " + (this.stackOffset + stackOffset) + "\n");
//                            code.add("ld l, [hl]\n");
//                            code.add("ld h, 0\n");
//                        }
//                        else if(bitNum == Constants.INT_SIZE)
//                        {
//                            code.add("ld hl, sp + " + (this.stackOffset + stackOffset) + "\n");
//                            code.add("ld a, [hl+]\n");
//                            code.add("ld h, [hl]\n");
//                            code.add("ld l, a\n");
//                        }
//                    }
//                    else if(type == VariableType.STATIC)
//                    {
//                        if(bitNum == Constants.CHAR_SIZE)
//                        {
//                            code.add("ld h, 0\n");
//                            code.add("ld a, [w" + arg.getContent() + "]\n");
//                            code.add("ld l, a\n");
//                        }
//                        else if(bitNum == Constants.INT_SIZE)
//                        {
//                            code.add("ld a, [w" + arg.getContent() + "]\n");
//                            code.add("ld l, a\n");
//                            code.add("ld a, [w" + arg.getContent() + " + 1]\n");
//                            code.add("ld h, a\n");
//                        }
//                    }
//                    else if(type == VariableType.OBJECT)
//                    {
//                        if(bitNum == Constants.CHAR_SIZE)
//                        {
//                            generateAddressForObjectVariable(code, arg.getContent(), stackOffset);
//                            code.add("ld l, [hl]\n");
//                            code.add("ld h, 0\n");
//                        }
//                        else
//                        {
//                            generateAddressForObjectVariable(code, arg.getContent(), stackOffset);
//                            code.add("ld a, [hl+]\n");
//                            code.add("ld h, [hl]\n");
//                            code.add("ld l, a\n");
//                        }
//                    }
//                    
//                    code.add("push hl\n");
//                    break;
//                }
//                case STRING:
//                {
//                    code.add("ld hl, _g" + Math.abs(arg.hashCode()) + "\n");
//                    code.add("push hl\n");
//                    //Put data into data part of file
//                    data.add("_g" + Math.abs(arg.hashCode()) + ":\n");
//                    data.add("DB \"" + arg.getContent() + "\", 0\n");
//                    break;
//                }
//                case ASM_REFERENCE:
//                {
//                    code.add("ld hl, " + arg.getContent() + "\n");
//                    code.add("push hl\n");
//                    break;
//                }
//                case CALL:
//                {
//                    generateMethodCall(code, arg, 0);
//                    code.add("push bc\n");
//                    break;
//                }
//                case OBJECT_CALL:
//                {
//                    int objectStackOffset = 0;
//                    String[] astParts = arg.getContent().split("\\|");
//                    if(astParts[0].equals("this"))
//                    {
//                        if(funcTree.getType() == TreeNodeType.CONSTRUCTOR)
//                        {
//                            for(String s : objectConstructors)
//                            {
//                                String[] parts = s.split("\\|");
//                                for(String instance : objectInstances)
//                                {
//                                    String[] iParts = instance.split("\\|");
//                                    //Check if the type is correct
//                                    if(iParts[0].equals(parts[0]))
//                                    {
//                                        stackOffset += Integer.parseInt(parts[1]) * 2; //Every argument takes 2 bytes on the stack, so we mult by 2
//                                        stackOffset += 2; //Also calculate in that the address we want is that of the pointer to the object
//                                        break;
//                                    }
//                                }
//                            }
//                        }
//                        else
//                        {
//                            for(String s : objectMethods)
//                            {
//                                String[] parts = s.split("\\|");
//                                if(parts[2].equals(funcTree.getContent()))
//                                {
//                                    objectStackOffset = Integer.parseInt(parts[3]) * 2;
//                                    objectStackOffset += 2; //Also calculate in that the address we want is that of the pointer to the object
//                                    break;
//                                }
//                            }
//                        }
//                    }
//                    
//                    generateMethodCall(code, arg, objectStackOffset  + stackOffset);
//                    code.add("push bc\n");
//                    break;
//                }
//            }
//            
//            stackOffset += 2;
//        }
//    }
//    
//    /**
//     * Generates a method call from an AbstractSyntaxTree
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param objectStackOffset Used for object calls, determines where the pointer to the object memory is located on the stack
//     * @return the bitNum of the return value (0 if method type is void) 
//     */
//    public int generateMethodCall(List<String> code, AbstractSyntaxTree tree, int objectStackOffset)
//    {
//        if(tryGenerateInlineMethodCall(code, tree))
//        {
//            return 0;
//        }
//        
//        int x = StdlibCallGenerator.getInstance().tryGenerateStdlibCall(tree, code, this, this.mbcVariant);
//        if(x != -1)
//        {
//            return x;
//        }
//        
//        boolean methodExists = false;
//        int returnBitNum = 0;
//        int arguments = 0;
//        
//        for(String s : staticMethods)
//        {
//            String[] parts = s.split("\\|");
//            if(parts[1].equals(tree.getContent()))
//            {
//                if(parts[0].equals("char"))
//                {
//                    returnBitNum = Constants.CHAR_SIZE;
//                }
//                else if(parts[0].equals("int"))
//                {
//                    returnBitNum = Constants.INT_SIZE;
//                }
//                
//                arguments = Integer.parseInt(parts[2]);
//                methodExists = true;
//                break;
//            }
//        }
//        
//        if(!methodExists && tree.getType() == TreeNodeType.OBJECT_CALL)
//        {
//            String[] parts = tree.getContent().split("\\|");
//            //Destroy the object
//            if(parts[1].equals("destroy"))
//            {
//                code.add("ld a, [w" + parts[0] + "]\n");
//                code.add("ld l, a\n");
//                code.add("ld a, [w" + parts[0] + " + 1]\n");
//                code.add("ld h, a\n");
//                code.add("ld de, -6\n");
//                code.add("add hl, de\n");
//                code.add("call free\n");
//            
//                code.add("xor a\n");
//                code.add("ld [w" + parts[0] + "], a\n");
//                code.add("ld [w" + parts[0] + " + 1], a\n");
//                return 0;
//            }
//            
//            //Also check if method exists for the type of object we're calling
//            for(String s : objectMethods)
//            {
//                String[] parts2 = s.split("\\|");
//                if(parts2[2].equals(parts[1]))
//                {
//                    if(parts2[1].equals("char"))
//                    {
//                        returnBitNum = Constants.CHAR_SIZE;
//                    }
//                    else if(parts2[1].equals("int"))
//                    {
//                        returnBitNum = Constants.INT_SIZE;
//                    }
//
//                    arguments = Integer.parseInt(parts2[3]);
//                    methodExists = true;
//                    break;
//                }
//            }
//        }
//        
//        if(!methodExists)
//        {
//            syntaxError(tree.getLine(), "Attempt to call nonexistent method.");
//        }
//
//        AbstractSyntaxTree args = null;
//
//        //Find the tree containing the function arguments
//        for(AbstractSyntaxTree child : tree.getChildren())
//        {
//            if(child.getType() == TreeNodeType.FUNC_ARGS)
//            {
//                args = child;
//                break;
//            }
//        }
//        
//        if(arguments != args.getChildren().size())
//        {
//            mismatchedArgumentNumberError(tree.getLine(), arguments, args.getChildren().size());
//        }
//        
//        //TO-DO: Allow using an address from the stack as well (for vars (objects) declared in funcs or for func args)?
//        //For an object call, push the address to the allocated memory first
//        if(tree.getType() == TreeNodeType.OBJECT_CALL)
//        {
//            String[] parts = tree.getContent().split("\\|");
//            
//            if(parts[0].equals("this"))
//            {
//                code.add("ld hl, sp + " + objectStackOffset + "\n");
//                code.add("ld a, [hl+]\n");
//                code.add("ld h, [hl]\n");
//                code.add("ld l, a\n");
//                code.add("push hl\n");
//            }
//            else
//            {
//                code.add("ld a, [w" + parts[0] + "]\n");
//                code.add("ld l, a\n");
//                code.add("ld a, [w" + parts[0] + " + 1]\n");
//                code.add("ld h, a\n");
//                code.add("push hl\n");
//            }
//        }
//        
//        generateMethodCallArguments(code, args, tree);
//
//        if(tree.getType() == TreeNodeType.OBJECT_CALL)
//        {
//            String[] parts = tree.getContent().split("\\|");
//            code.add("call " + parts[1] + "\n");
//        }
//        else
//        {
//            code.add("call " + tree.getContent() + "\n");
//        }
//
//        int toPop = args.getChildren().size() * 2;
//        if(tree.getType() == TreeNodeType.OBJECT_CALL)
//        {
//            toPop += 2;
//        }
//        
//        if(toPop > 0)
//        {
//            code.add("add sp, " + toPop + "\n");
//        }
//        
//        return returnBitNum;
//    }
//    
//    /**
//     * Generates a method return
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateReturn(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        int bitNum = 0;
//        VariableType varType;
//        
//        if(tree.getChildren().get(0).getType() == TreeNodeType.VARIABLE)
//        {
//            VarHelper vh = this.doVariableAccess(tree.getChildren().get(0), isStatic);
//            bitNum = vh.getBitNum();
//            varType = vh.getVarType();
//            
//            if(varType == VariableType.FUNC_ARG || varType == VariableType.STACK_VAR)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld c, [hl]\n");
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld hl, sp + " + stackOffset + "\n");
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld a, [hl]\n");
//                    code.add("ld b, a\n");
//                }
//            }
//            else if(varType == VariableType.STATIC)
//            {
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld b, 0\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                    code.add("ld b, a\n");
//                    code.add("ld a, [w" + tree.getChildren().get(0).getContent() + " + 1]\n");
//                    code.add("ld c, a\n");
//                }
//            }
//            else if(varType == VariableType.OBJECT)
//            {
//                generateAddressForObjectVariable(code, tree.getChildren().get(0).getContent(), 0);
//
//                if(bitNum == Constants.CHAR_SIZE)
//                {
//                    code.add("ld b, 0\n");
//                    code.add("ld c, [hl]\n");
//                }
//                else if(bitNum == Constants.INT_SIZE)
//                {
//                    code.add("ld a, [hl+]\n");
//                    code.add("ld c, a\n");
//                    code.add("ld b, [hl]\n");
//                }
//            }
//        }
//        else if(tree.getChildren().get(0).getType() == TreeNodeType.CONSTANT)
//        {
//            int value = Integer.parseInt(tree.getChildren().get(0).getContent());
//            
//            if(value <= 255 || value >= -128)
//            {
//                bitNum = Constants.CHAR_SIZE;
//                code.add("ld b, 0\n");
//                code.add("ld c, " + value + "\n");
//            }
//            else if(value <= 65535 || value >= -32768)
//            {
//                bitNum = Constants.INT_SIZE;
//                code.add("ld bc, " + value + "\n");
//            }
//            else
//            {
//                numberTooBigError(tree.getChildren().get(0).getLine());
//            }
//        }
//        else if(tree.getChildren().get(0).getType() == TreeNodeType.ARRAY_ACCESS)
//        {
//            VarHelper vh = this.doVariableAccess(tree.getChildren().get(0), isStatic);
//            bitNum = vh.getBitNum();
//            varType = vh.getVarType();
//            
//            generateArrayAccess(code, tree.getChildren().get(0), bitNum, isStatic, false);
//        }
//        
//        //Check if what we return here is correct (same as declared method return type)
//        if(isStatic)
//        {
//            for(String s : staticMethods)
//            {
//                String[] parts = s.split("\\|");
//                if(parts[1].equals(currentFunction.getContent()))
//                {
//                    if(parts[0].equals("char") && bitNum == Constants.CHAR_SIZE)
//                    {
//                        break;
//                    }
//                    else if(parts[0].equals("int") && (bitNum == Constants.CHAR_SIZE || bitNum == Constants.INT_SIZE))
//                    {
//                        break;
//                    }
//                    else
//                    {
//                        syntaxError(tree.getLine(), "Return uses different type than declared in method header.");
//                    }
//                }
//            }
//        }
//        else
//        {
//            for(String s : objectMethods)
//            {
//                String[] parts = s.split("\\|");
//                if(parts[2].equals(currentFunction.getContent()))
//                {
//                    if(parts[1].equals("char") && bitNum == Constants.CHAR_SIZE)
//                    {
//                        break;
//                    }
//                    else if(parts[1].equals("int") && (bitNum == Constants.CHAR_SIZE || bitNum == Constants.INT_SIZE))
//                    {
//                        break;
//                    }
//                    else
//                    {
//                        syntaxError(tree.getLine(), "Return uses different type than declared in method header.");
//                    }
//                }
//            }
//        }
//        
//        if(popOnReturn)
//        {
//            //We are not saving bc because that is the return value
//            code.add("pop hl\n");
//            code.add("pop de\n");
//            code.add("pop af\n");
//        }
//        
//        code.add("ret\n");
//    }
//    
//    /**
//     * Generates a switch statement<br>
//     * Works via a jump table
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateSwitchStatement(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        List<String> jumpTable = new ArrayList<String>();
//        jumpTable.add("jt" + tree.hashCode() + ":\n");
//        
//        List<String> switchCases = new ArrayList<String>();
//        
//        //Generate jump table usage code
//        VarHelper vh = this.doVariableAccess(tree.getChildren().get(0), isStatic);
//        int bitNum = vh.getBitNum();
//        VariableType varType = vh.getVarType();
//
//        if(varType == VariableType.FUNC_ARG || varType == VariableType.STACK_VAR)
//        {
//            if(bitNum == Constants.CHAR_SIZE)
//            {
//                code.add("ld hl, sp + " + stackOffset + "\n");
//                code.add("ld l, [hl]\n");
//                code.add("ld h, 0\n");
//            }
//            else if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("ld hl, sp + " + stackOffset + "\n");
//                code.add("ld a, [hl+]\n");
//                code.add("ld h, [hl]\n");
//                code.add("ld l, a\n");
//            }
//        }
//        else if(varType == VariableType.STATIC)
//        {
//            if(bitNum == Constants.CHAR_SIZE)
//            {
//                code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                code.add("ld l, a\n");
//                code.add("ld h, 0\n");
//            }
//            else if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("ld a, [w" + tree.getChildren().get(0).getContent() + "]\n");
//                code.add("ld l, a\n");
//                code.add("ld a, [w" + tree.getChildren().get(0).getContent() + " + 1]\n");
//                code.add("ld h, a\n");
//            }
//        }
//        else if(varType == VariableType.OBJECT)
//        {
//            generateAddressForObjectVariable(code, tree.getChildren().get(0).getContent(), 0);
//
//            if(bitNum == Constants.CHAR_SIZE)
//            {
//                code.add("ld l, [hl]\n");
//                code.add("ld h, 0\n");
//            }
//            else if(bitNum == Constants.INT_SIZE)
//            {
//                code.add("ld a, [hl+]\n");
//                code.add("ld h, [hl]\n");
//                code.add("ld l, a\n");
//            }
//        }
//        
//        //Check against highest number (see if we're out of bounds)
//        int biggestCase = 0;
//        int biggestCaseAstLine = -1;
//        for(AbstractSyntaxTree ast : tree.getChildren())
//        {
//            if(ast.getType() == TreeNodeType.CASE)
//            {
//                int i = Integer.parseInt(ast.getContent());
//                if(i > biggestCase)
//                {
//                    biggestCase = i;
//                    biggestCaseAstLine = ast.getLine();
//                }
//            }
//        }
//        
//        //TO-DO: Add conversion from switch case indices into actual indices and thus allow using 16-bit numbers?
//        if(biggestCase > 255)
//        {
//            syntaxError(biggestCaseAstLine, "Case index out of bounds.");
//        }
//        code.add("ld a, l\n");
//        code.add("ld c, " + biggestCase + "\n");
//        code.add("ld de, jt" + tree.hashCode() + "\n");
//        code.add("call jumpTableCaller\n");
//        code.add("jtce" + tree.hashCode() + ":\n");
//        
//        //Generate methods for each case, and the table itself
//        for(AbstractSyntaxTree ast : tree.getChildren())
//        {
//            if(ast.getType() == TreeNodeType.CASE)
//            {
//                //Generate code for the switch case
//                switchCases.add("jte" + ast.hashCode() + ":\n");
//                generateStatementSequence(switchCases, ast, isStatic);
//                //Jump back to where the call was made
//                switchCases.add("jp jtce" + tree.hashCode() + "\n");
//
//                //Generate label into jump table
//                int caseIndex = Integer.parseInt(ast.getContent());
//                
//                if(jumpTable.size() <= caseIndex + 1)
//                {
//                    while(jumpTable.size() < caseIndex + 1)
//                    {
//                        jumpTable.add("DW 0\n");
//                    }
//                    jumpTable.add("DW jte" + ast.hashCode() + "\n");
//                }
//                else
//                {
//                    jumpTable.set(caseIndex + 1, "DW jte" + ast.hashCode() + "\n");
//                }
//            }
//        }
//        
//        data.addAll(jumpTable);
//        data.addAll(switchCases);
//    }
//    
//    /**
//     * A statement sequence - can be inside a method, contructor or any control structure
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateStatementSequence(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        for(AbstractSyntaxTree ast : tree.getChildren())
//        {
//            switch(ast.getType())
//            {
//                case DECLARATION:
//                {
//                    if(isStatic)
//                    {
//                        code.add("add sp, -2\n"); //"Allocate" space on stack
//                        methodVarDeclarations.add(tree.getContent() + "|" + ast.getContent());
//                    }
//                    else
//                    {
//                        syntaxError(ast.getLine(),
//                                "Variable definitions inside methods of object classes are not allowed. Use an object-level variable instead. :)");
//                    }
//                    break;
//                }
//                case ASSIGNMENT:
//                {
//                    generateAssignment(code, ast, isStatic);
//                    break;
//                }
//                case CALL:
//                {
//                    generateMethodCall(code, ast, 0);
//                    break;
//                }
//                case OBJECT_CALL:
//                {
//                    int stackOffset = 0;
//                    String[] astParts = ast.getContent().split("\\|");
//                    if(astParts[0].equals("this"))
//                    {
//                        if(tree.getType() == TreeNodeType.CONSTRUCTOR)
//                        {
//                            for(String s : objectConstructors)
//                            {
//                                String[] parts = s.split("\\|");
//                                
//                                for(String instance : objectInstances)
//                                {
//                                    String[] iParts = instance.split("\\|");
//                                    //Check if the type is correct
//                                    if(iParts[0].equals(parts[0]))
//                                    {
//                                        stackOffset += Integer.parseInt(parts[1]) * 2; //Every argument takes 2 bytes on the stack, so we mult by 2
//                                        stackOffset += 2; //Also calculate in that the address we want is that of the pointer to the object
//                                        break;
//                                    }
//                                }
//                            }
//                        }
//                        else
//                        {
//                            for(String s : objectMethods)
//                            {
//                                String[] parts = s.split("\\|");
//                                if(parts[2].equals(tree.getContent()))
//                                {
//                                    stackOffset = Integer.parseInt(parts[3]) * 2;
//                                    stackOffset += 2; //Also calculate in that the address we want is that of the pointer to the object
//                                    break;
//                                }
//                            }
//                        }
//                    }
//                    generateMethodCall(code, ast, stackOffset);
//                    break;
//                }
//                case IF:
//                {
//                    generateIfElseBlock(code, ast, isStatic);
//                    break;
//                }
//                case WHILE:
//                {
//                    generateWhileLoop(code, ast, isStatic);
//                    break;
//                }
//                case SWITCH:
//                {
//                    generateSwitchStatement(code, ast, isStatic);
//                    break;
//                }
//                case RETURN:
//                {
//                    generateReturn(code, ast, isStatic);
//                    break;
//                }
//            }
//        }
//    }
//    
//    /**
//     * Generates a function
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param isStatic Determines if this is a section (static) or an object class
//     */
//    private void generateFunction(List<String> code, AbstractSyntaxTree tree, boolean isStatic)
//    {
//        this.currentFunction = tree;
//     
//        popOnReturn = false;
//        
//        int returnBitNum = 0;
//        
//        for(String s : staticMethods)
//        {
//            String[] parts = s.split("\\|");
//            if(parts[1].equals(currentFunction.getContent()))
//            {
//                if(parts[0].equals("char"))
//                {
//                    returnBitNum = Constants.CHAR_SIZE;
//                    break;
//                }
//                else if(parts[0].equals("int"))
//                {
//                    returnBitNum = Constants.INT_SIZE;
//                    break;
//                }
//            }
//        }
//        
//        code.add(tree.getContent() + ":\n");
//        
//        if(tree.getContent().equals("VBlank"))
//        {
//            code.add("push af\n");
//            code.add("push bc\n");
//            code.add("push de\n");
//            code.add("push hl\n");
//        }
//        else if(returnBitNum != 0)
//        {
//            popOnReturn = true;
//            //We are not saving bc because that is the return value
//            code.add("push af\n");
//            code.add("push de\n");
//            code.add("push hl\n");
//        }
//        
//        generateStatementSequence(code, tree, isStatic);
//        
//        code.add("add sp, " + (getNumberOfVarsForCurrentMethod() * 2) + "\n");
//        
//        if(tree.getContent().equals("VBlank"))
//        {
//            code.add("pop hl\n");
//            code.add("pop de\n");
//            code.add("pop bc\n");
//            code.add("pop af\n");
//        }
//        else if(returnBitNum != 0)
//        {
//            //We are not saving bc because that is the return value
//            code.add("pop hl\n");
//            code.add("pop de\n");
//            code.add("pop af\n");
//        }
//        
//        if(tree.getContent().equals("VBlank"))
//        {
//            //When an interrupt handler is called, interrupts are automatically disabled
//            //We need to reenable them after the interrupt handler again
//            //reti is basically ei + ret in one handy instruction 
//            code.add("reti\n");
//        }
//        else
//        {
//            code.add("ret\n");
//        }
//    }
//    
//    /**
//     * Generates a constructor for an (object) class
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     * @param className The name of the class this constructor belongs to
//     */
//    private void generateConstructor(List<String> code, AbstractSyntaxTree tree, String className)
//    {
//        tree.setContent("_" + className + "Constructor");
//        generateFunction(code, tree, false);
//    }
//    
//    /**
//     * Since we receive a single string containing multiple lines, we need to split it<br>
//     * Each element of the code array is one line
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     */
//    private void generateInlineAssembly(List<String> code, AbstractSyntaxTree tree)
//    {
//        String[] parts = tree.getContent().split("\n");
//        for(String s : parts)
//        {
//            code.add(s + "\n");
//        }
//    }
//    
//    /**
//     * Generates a section
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     */
//    private void generateStaticClass(List<String> code, AbstractSyntaxTree tree)
//    {
//        for(AbstractSyntaxTree ast : tree.getChildren())
//        {
//            switch(ast.getType())
//            {
//                case PACKAGE:
//                {
//                    code.add(" SECTION \"" + tree.getContent() + "\", " + ast.getContent() + "\n");
//                    break;
//                }
//                case DECLARATION:
//                {
//                    generateDeclaration(ast);
//                    break;
//                }
//                case FUNCTION:
//                {
//                    generateFunction(code, ast, true);
//                    break;
//                }
//                case INLINE_ASM:
//                {
//                    generateInlineAssembly(code, ast);
//                    break;
//                }
//                case ARRAY_DECLARATION:
//                {
//                    String[] parts = ast.getContent().split("\\|");
//                    int numBytes = Integer.parseInt(parts[1]);
//                    if(!parts[0].equals("char"))
//                    {
//                        numBytes *= 2;
//                    }
//                    varDeclarations.add("array|" + parts[2] + "|" + parts[0] + "|" + numBytes);
//                    break;
//                }
//            }
//        }
//    }
//    
//    /**
//     * Generates an (object) class
//     * 
//     * @param code The arraylist the generated code is written into
//     * @param tree The AST we're generating the code from
//     */
//    private void generateClass(List<String> code, AbstractSyntaxTree tree)
//    {
//        for(AbstractSyntaxTree ast : tree.getChildren())
//        {
//            switch(ast.getType())
//            {
//                case PACKAGE:
//                {
//                    code.add(" SECTION \"" + tree.getContent() + "\", " + ast.getContent() + "\n");
//                    break;
//                }
//                case DECLARATION:
//                {
//                    objectVariableDeclarations.add(tree.getContent() + "|" + ast.getContent());
//                    break;
//                }
//                case FUNCTION:
//                {
//                    generateFunction(code, ast, false);
//                    break;
//                }
//                case INLINE_ASM:
//                {
//                    generateInlineAssembly(code, ast);
//                    break;
//                }
//                case CONSTRUCTOR:
//                {
//                    generateConstructor(code, ast, tree.getContent());
//                    break;
//                }
//            }
//        }
//    }
//    
//    /**
//     * Generates an assembly file from a .gbj file
//     * Also runs the optimizer, if any passes are requested
//     * 
//     * @param isMainFile Determines if this is the main file of the project
//     */
//    public void generateAsmFile(boolean isMainFile)
//    {
//        List<String> code = this.generatedCode;
//        
//        if(isMainFile)
//        {
//            code.add("INCLUDE \"stdlib/RomHeader.asm\"\n");
//        }
//        
//        for(AbstractSyntaxTree ast : syntaxTree.getChildren())
//        {
//            switch(ast.getType())
//            {
//                case SECTION:
//                {
//                    generateStaticClass(code, ast);
//                    break;
//                }
//                case CLASS:
//                {
//                    generateClass(code, ast);
//                    break;
//                }
//                case IMPORT:
//                {
//                    if(ast.getContent().endsWith(".gbj"))
//                    {
//                        AssemblerRunner.runCompiler(ast.getContent());
//                        code.add("INCLUDE \"build/" + ast.getContent().substring(0, ast.getContent().length() - 4) + ".asm\"\n");
//                    }
//                    else
//                    {
//                        code.add("INCLUDE \"" + ast.getContent() + "\"\n");
//                    }
//                    break;
//                }
//            }
//        }
//        
//        //Append data to end of normal code section
//        code.add("INCLUDE \"stdlib/charmap.asm\"\n"); //The charmap contains no data, but instead maps the ASCII characters in strings onto other numbers
//        for(String s : data)
//        {
//            code.add(s);
//        }
//        
//        //Generate WRAM variable section
//        code.add(" SECTION \"Vars\", WRAM0\n");
//        for(String s : varDeclarations)
//        {
//            // "|" needs to be escaped: https://stackoverflow.com/questions/10796160/splitting-a-java-string-by-the-pipe-symbol-using-split
//            String[] parts = s.split("\\|");
//            
//            //Char is 1 byte
//            if(parts[0].equals("char"))
//            {
//                code.add("w" + parts[1] + ": DS 1\n");
//            }
//            //Int is 2 bytes
//            else if(parts[0].equals("int"))
//            {
//                code.add("w" + parts[1] + ": DS 2\n");
//            }
//            //Arrays store their size
//            else if(parts[0].equals("array"))
//            {
//                code.add("w" + parts[1] + ": DS " + parts[3] + "\n");
//            }
//            //Objects (actually, we store their pointers) are 2 bytes
//            else
//            {
//                code.add("w" + parts[1] + ": DS 2\n");
//            }
//        }
//        
//        Optimizer op = new Optimizer(code);
//        
//        for(int i = 0; i < optimizerPasses; i++)
//        {
//            op.optimize();
//        }
//        
//        //A simple autoformatter, basically
//        for(int i = 0; i < code.size(); i++)
//        {
//            //E F F I C I E N C Y
//            if(!(code.get(i).endsWith(":\n") || code.get(i).startsWith(" SECTION") || code.get(i).startsWith("INCLUDE") || code.get(i).startsWith("w")))
//            {
//                code.set(i, "    " + code.get(i));
//            }
//        }
//        
//        Logger.getInstance().log(Logger.FINE, "Total number of optimizer passes: " + optimizerPasses);
//        
//        //Write the generated code out to disk
//        try
//        {
//            for(String s : code)
//            {
//                writer.write(s);
//            }
//            writer.close();
//        }
//        catch(IOException e)
//        {
//            Logger.getInstance().log(Logger.ERROR, "Failed to close file writer.");
//            Logger.getInstance().log(Logger.ERROR, e);
//        }
//    }
//    
//    public List<String> getData()
//    {
//        return data;
//    }
}